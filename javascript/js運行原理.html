<!-- 調用棧 call stack -->
直擺的
當調用時 才會入調用棧

打斷點觀察

    <!-- 执行函数順序 -->
    |先创建函数执行上下文，压入执行栈顶；
    |执行函数函数。

    <!-- stackoverflow -->
    出現在遞規調用 無終止時

    <!-- 造成問題 -->
    js只有一個線程 意味著只有一個調用棧
    如果overflowing 會阻塞線程
    頁面的布局繪製 也都在這線程 overflowing就會影響渲染

<!-- queue -->
橫擺的


<!-- Execution Context 執行上下文 -->
函数被调用时会创建个执行上下文对象，用于存储函数执行时涉及的相关的数据

    <!-- 全局作用域创建 -->
    在首次执行脚本时创建的

    <!-- 函数执行上下文创建 -->
    分为两个阶段：创建阶段 / 执行阶段

<!-- invocation -->
看到() 創造一個新的 execution context
結束該函數 該execution context 會離開call stack
this變數 被創造給那個函數 ? 裡面的變數 在创建阶段建立 ?

<!-- functions context -->

<!-- variable environments -->
每個execution context都有自己的variable environment
invocation 時 會創造 execution context 和 variable environment
變數都在自己的scope裡面 互相不關連

<!-- Scope Chain -->

    <!-- 外部參照 -->
    每個 execution context 有一個參照的外部環境
    lexical environment - 程式被寫出來的物理位置(而這位置可能就在人家的execution context裡面)

<!-- 同步非同步 -->
瀏覽器有很多引擎 只有js引擎是同步的
"非同步部分 發生在js引擎外"
js引擎外的事件 放在 queue
stack空了 global execution context 清除了 queue才會處理 並且是同步處理

<!--  -->
https://darjun.github.io/2018/12/03/javascript-execution-context/

在去了解EventLoop之前，
你要先理解呼叫堆疊的運作 這就是CallStack
也就是Js怎麼處理一個個任務的，

每次呼叫一個函數，會產生一個新的呼叫結構壓入CallStack