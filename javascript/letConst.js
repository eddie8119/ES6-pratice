// let声明的变量只在它所在的代码块有效
{
  let a = 10;
  var b = 1;
}

// ----------------------------------------
// for循环的计数器，就很合适使用let命令
// 计数器i只在for循环体内有效，在循环体外引用就会报错
for (let i=0; i<10; i++){

}

// for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域 (要聯想到塊級作用域的觀念)
for (let i=0; i<10; i++){
  let i = 'abc'  
}

// ----------------------------------------
// let const 不存在變量提升
//纠正这种现象 声明的变量一定要在声明后使用，否则报错。

// ----------------------------------------
//  let const 暂时性死区
// 使用let命令声明变量之前，该变量都是不可用的

// 有些“死区”比较隐蔽，不太容易发现。
function bar(x = y, y = 2) { //y还没有声明
  return [x, y];
}


// ----------------------------------------
//  let const 為什麼要塊級作用域
// 1.內層必輛覆蓋外層
// 2.循環變量洩漏全局

// ----------------------------------------
// 塊級作用域與函數聲明
// 浏览器的 ES6 环境中，块级作用域内声明的函数，行为类似于var声明的变量。
function f() { console.log('I am outside!'); }
(function () {
  var f = undefined;
  if (false) {
    function f() { console.log('I am inside!'); }
  }

  f(); // Uncaught TypeError: f is not a function
}());

// 考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。
// 如果确实需要，也应该写成函数表达式，而不是函数声明语句。
{
  let a = 'secret';
  function f() {
    return a;
  }
}

// 块级作用域内部，优先使用函数表达式
{
  let a = 'secret';
  let f = function () {
    return a;
  };
}











// const

// const声明一个只读的常量。一旦声明，常量的值就不能改变
// 这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值
// const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。(指向地址不可变)

// ----------------------------------------
// ES6 一共有 6 种声明变量的方法
// var function let const import class

// ----------------------------------------
// 顶层对象属性
// let命令、const命令、class命令声明的全局变量 将逐步与顶层对象的属性脱钩

var a = 1 
window.a //1

let b = 1 
window.b // undefined
